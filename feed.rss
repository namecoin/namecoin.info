<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Namecoin</title>
    <description><!--Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
--></description>
    <link>https://www.namecoin.org/</link>
    <atom:link href="https://www.namecoin.org/feed.rss" rel="self" type="application/rss+xml" />
    <language>en</language>
    <pubDate>Fri, 15 Jan 2021 06:21:34 +0000</pubDate>
    <lastBuildDate>Fri, 15 Jan 2021 06:21:34 +0000</lastBuildDate>
    <generator>Jekyll</generator>
    <image>
      <url>https://www.namecoin.org/images/logo.png</url>
      <title>Namecoin</title>
      <link>https://www.namecoin.org/</link>
      <width>134</width>
      <height>25</height>
    </image>
    
      <item>
        <title>Undocumented Windows Feature: External Name Constraints</title>
        <description>&lt;p&gt;Name constraints are a little-known gem of a feature in X.509 certificates, which are used for TLS.  A name constraint is a certificate extension, applied to a CA’s certificate, that contains a whitelist and/or blacklist of names (e.g. domain names) that the CA can issue certs for.  There are 3 main reasons why a CA might want to have a name constraint:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A commercial public CA might sell you a CA for your personal use, with a name constraint that whitelists only domains that you’ve demonstrated that you control.  This works similarly to selling you an end-entity certificate, except that now you can renew your end-entity cert (perhaps rotating keys) without needing to interact with the commercial CA, since you now have your own CA you can use.  This use case isn’t really used in practice, mostly because of regulatory capture (commercial CA’s have successfully made sure that the CA/Browser Forum regulations prohibit issuing name-constrained CA’s to members of the general public).&lt;/li&gt;
  &lt;li&gt;A private CA, perhaps belonging to a corporate intranet or other internal network, wants to limit the damage it can do if it is later compromised, so it includes a name constraint that whitelists a TLD belonging to its intranet.  Thus, if the private CA is later compromised, it can’t be used to attack websites on the public Internet.  This is the stated motivation for Netflix’s BetterTLS test suite.&lt;/li&gt;
  &lt;li&gt;A public CA wants to prevent itself from issuing certificates for specific TLD’s that have unique regulatory requirements that the CA isn’t able to comply with, so it includes a name constraint that blacklists those TLD’s.  Thus, users of those TLD’s don’t have to worry about the public CA affecting their environment.  The best-known example of this is that the Let’s Encrypt CA has sometimes used a name constraint that blacklisted &lt;code class=&quot;highlighter-rouge&quot;&gt;.mil&lt;/code&gt;, presumably because the U.S. military PKI has regulatory requirements that Let’s Encrypt didn’t want to mess with.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All of these use cases are quite valid and legitimate, but they assume one thing: that the CA &lt;em&gt;wanted&lt;/em&gt; to be subjected to a name constraint.  What do you do if you’ve been given a CA certificate that &lt;em&gt;doesn’t&lt;/em&gt; have a name constraint, and you want to only trust it for a subset of names?&lt;/p&gt;

&lt;p&gt;One approach is to cross-sign the CA – in other words, you create your own CA with the name constraint you want, and then produce a cert that’s identical to the CA you want to constrain, except with an issuer and signature from your constrained CA.  This is not too hard; I actually wrote a tool called &lt;code class=&quot;highlighter-rouge&quot;&gt;crosssignnameconstraint&lt;/code&gt; that does this for you.  It works pretty well, but it does produce two potentially unwanted side effects:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It transforms a root CA into an intermediate CA.&lt;/li&gt;
  &lt;li&gt;It changes the fingerprint of the CA.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Both of these can result in unintended behavior from poorly designed TLS implementations, e.g. certificate pinning and EV certificates may behave differently when you cross-sign a certificate.&lt;/p&gt;

&lt;p&gt;So, is there another approach we can use?  If you’re on Windows, then the answer is yes!&lt;/p&gt;

&lt;p&gt;Windows CryptoAPI stores certificates &lt;a href=&quot;/2017/05/27/reverse-engineering-cryptoapi-cert-blobs.html&quot;&gt;in a kind of funky way&lt;/a&gt;: certificates are stored not just in DER-encoded form, but in a custom data structure called a “certificate blob” that allows “properties” to be attached to the certificates.  One example of such a property is a constraint on which extended key usages a CA can be used for.  For example, you might want to import a CA that’s allowed to issue TLS client certificates but not allowed to issue TLS server certificates or sign code.  When I was looking at the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty#parameters&quot;&gt;list of properties&lt;/a&gt;, most looked pretty mundane, but one jumped out: what the heck is this &lt;code class=&quot;highlighter-rouge&quot;&gt;CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID&lt;/code&gt; thing?  Curiously, the documentation doesn’t say what it does; it’s simply marked as “Reserved”.  However, looking at other properties’ documentation, it became clear that Microsoft has a habit of encoding extensions in ASN.1 format and stuffing the resulting binary data into a property.  I also noticed that the Windows utility &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; actually has a way to edit arbitrary properties of certificates; it’s the (confusingly named) &lt;code class=&quot;highlighter-rouge&quot;&gt;-repairstore&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;So, I cooked up a certificate that had a name constraint blacklisting &lt;code class=&quot;highlighter-rouge&quot;&gt;.github.io&lt;/code&gt;, extracted the ASN.1 binary data for the name constraint extension into a hex blob, and instructed &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; to set it on the built-in root CA that GitHub Pages uses.  I then tried to visit GitHub Pages in Chromium, and &lt;strong&gt;boom&lt;/strong&gt;: a TLS error.  Inspecting the CryptoAPI logs confirmed that the failure was due to a name constraint.&lt;/p&gt;

&lt;p&gt;So, why is this feature there?  Is it being used anywhere?  As far as I can tell, it’s not used by anyone.  The name of the property suggests that Microsoft intended to ship name constraints with its 3rd-party root CA’s, but I briefly checked the entire list of 3rd-party root CA’s, and it appears that none of them have this property set.  The property was added to Windows over a decade ago (if Wine commit dates are to be believed), so perhaps Microsoft used it in the past and then decided to stop.  Or perhaps they planned to use it, abandoned the plan, and left the code in place.  Maybe it was intended for private PKI purposes, but later got shelved.  Microsoft doesn’t document what this property does anywhere, and in fact I was unable to find even a single &lt;em&gt;mention&lt;/em&gt; of this property on the public Internet besides the source code to Microsoft’s header files and the Microsoft documentation that marks it as “Reserved”.  Amusingly, &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; knows exactly what this property is, and if you enable verbose output, it will even happily deserialize the name constraint ASN.1 data into a nice human-readable representation of the name constraint you’re applying.&lt;/p&gt;

&lt;p&gt;Reserved or not, it definitely works, and it seems like a useful addition to a PKI toolbox.  NSS, GnuTLS, and p11-kit do support external name constraints as well, but NSS requires a recompile if you want to change them, and the support in GnuTLS and p11-kit only works on a few distros (and no mainstream browsers).  By supporting external name constraints that are actually enforced in arbitrary applications (including mainstream browsers) and can be edited by the user, Windows is leading the way on an excellent feature (Windows support for this long predates GnuTLS and p11-kit support) – it’s too bad that Microsoft didn’t bother to advertise this as a selling point.&lt;/p&gt;

&lt;p&gt;More details on how we’re going to use this functionality in Namecoin will be in a future post.&lt;/p&gt;
</description>
        <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
        <link>https://www.namecoin.org/2021/01/14/undocumented-windows-feature-external-name-constraints.html</link>
        <guid isPermaLink="true">https://www.namecoin.org/2021/01/14/undocumented-windows-feature-external-name-constraints.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>External Name Constraints in certinject</title>
        <description>&lt;p&gt;In my &lt;a href=&quot;/2021/01/07/undocumented-windows-feature-external-name-constraints.html&quot;&gt;previous post&lt;/a&gt;, I introduced the undocumented Windows feature for external name constraints, which allow us to apply a name constraint without the consent of a CA, and without needing to cross-sign the CA.  I mentioned that the Windows utility &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; can be tricked into setting this Property on a certificate using the &lt;code class=&quot;highlighter-rouge&quot;&gt;-repairstore&lt;/code&gt; command.  Alas, abusing &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; to do this comes with some problems:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;-repairstore&lt;/code&gt; command looks suspiciously like it’s intended to be used for totally different purposes, and I simply do not trust it to only set a name constraint and nothing else.&lt;/li&gt;
  &lt;li&gt;Using &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; to edit a public CA requires Administrator privileges, which is not great from a sandboxing perspective.&lt;/li&gt;
  &lt;li&gt;We’d ideally like to apply the name constraint to &lt;em&gt;all&lt;/em&gt; of the root CA’s in the certificate store, not just a single one.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; API doesn’t exactly make this &lt;em&gt;impossible&lt;/em&gt;, but the UX is a lot worse than, say, the &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrictnss&lt;/code&gt; tool I wrote that does something comparable for the NSS TLS library.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Those of you who’ve looked at the ncdns source code will recall that ncdns includes a library called &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt;, which is designed to interact with Windows cert stores without needing Administrator privileges.  Since &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; isn’t free software, but &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; is, and &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; already solves the privilege issue for us, Aerth and I have been extending &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; to do what’s needed for external name constraints.&lt;/p&gt;

&lt;h2 id=&quot;injecting-to-arbitrary-cert-stores&quot;&gt;Injecting to Arbitrary Cert Stores&lt;/h2&gt;

&lt;p&gt;The original &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; code only could write to the &lt;code class=&quot;highlighter-rouge&quot;&gt;Root&lt;/code&gt; logical cert store in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Enterprise&lt;/code&gt; physical cert store.  This is where root CA’s added by the system administrator would, by convention, be stored.  This is fine for &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt;’s original purpose of injecting self-signed certs for Namecoin websites, but all the CA’s we want to apply a name constraint to are elsewhere: generally in either the &lt;code class=&quot;highlighter-rouge&quot;&gt;Root&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; logical cert store in the &lt;code class=&quot;highlighter-rouge&quot;&gt;System&lt;/code&gt; physical cert store.  (&lt;code class=&quot;highlighter-rouge&quot;&gt;Root&lt;/code&gt; is where the Microsoft root CA’s live; &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; is where the root CA’s run by non-Microsoft corporations live.)  &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; can now inject certs into arbitrary logical stores (including the &lt;code class=&quot;highlighter-rouge&quot;&gt;Disallowed&lt;/code&gt; logical store, which is used to mark a certificate as revoked), and now supports the &lt;code class=&quot;highlighter-rouge&quot;&gt;System&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Group-Policy&lt;/code&gt; physical stores in addition to the previously supported &lt;code class=&quot;highlighter-rouge&quot;&gt;Enterprise&lt;/code&gt; physical store.&lt;/p&gt;

&lt;h2 id=&quot;serializing-properties&quot;&gt;Serializing Properties&lt;/h2&gt;

&lt;p&gt;Originally, &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; only serialized Blobs that included the DER-encoded certificate, with no other Properties set.  This worked fine for its original purpose, but we needed to make it more flexible.  &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; can now serialize Blobs with arbitrary Properties set.  &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt;’s list of Properties supported by Windows is generated (to Go source code) via a Bash script (lots of &lt;code class=&quot;highlighter-rouge&quot;&gt;grep&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sed&lt;/code&gt;) using the &lt;code class=&quot;highlighter-rouge&quot;&gt;wincrypt.h&lt;/code&gt; file from ReactOS as input.  Curiously, &lt;code class=&quot;highlighter-rouge&quot;&gt;wincrypt.h&lt;/code&gt; only seems to contain the Properties supported by Windows XP.  A bunch of extra Properties were added in Windows Vista, but these are only listed in another header file, &lt;code class=&quot;highlighter-rouge&quot;&gt;certenroll.h&lt;/code&gt;, which does not appear to exist in the ReactOS source code yet.  At the moment, we don’t have any urgent need for the Vista Properties, so we’re sticking with the ReactOS header file for maximum free-software-ness.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; can also now generate the binary data for Properties involving either EKU (extended key usage) or name constraints.  The Golang standard library doesn’t exactly make this easy; we settled on the approach of setting the EKU or name constraint fields in an &lt;code class=&quot;highlighter-rouge&quot;&gt;x509.Certificate&lt;/code&gt; template, serializing the entire certificate, deserializing the result back to a template, and searching the template’s list of parsed &lt;code class=&quot;highlighter-rouge&quot;&gt;Extensions&lt;/code&gt; for something that matched the OID of either EKU or name constraints.  A tad inefficient, but this approach does seem to maximize the usage of stable, production-grade standard library API’s compared to custom parsing code on our end, so I think it’s safer than trying to roll our own super-efficient implementation.&lt;/p&gt;

&lt;p&gt;While I was writing the EKU serialization code, I noticed that the Go standard library supports two EKU values that I had never heard of: &lt;code class=&quot;highlighter-rouge&quot;&gt;ExtKeyUsageMicrosoftServerGatedCrypto&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ExtKeyUsageNetscapeServerGatedCrypto&lt;/code&gt;.  Some DDG-ing revealed that these are a historical relic of 1990’s-era export-grade cryptography (also referred to as “International Step-Up”).  In particular, I found a Mozilla Bugzilla bug indicating that modern TLS implementations still support these 1990’s-era abominations because there exist public CA certs that rely on those particular EKU values, which didn’t expire until 2020.  I decided to explicitly not support these EKU values in &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt;; users who desire to see some mildly more colorful language describing my opinion of this functionality can grep the &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; source code for “beehive”.&lt;/p&gt;

&lt;p&gt;We intend to add support for more Properties later; there are several other Properties that have caught our eye, although they’re not a very high priority for us right now.&lt;/p&gt;

&lt;p&gt;The only other notable issue we encountered in Blob serialization is that we found experimentally that the Property containing the DER-encoded certificate &lt;strong&gt;must&lt;/strong&gt; be the final Property in the serialized Blob.  Any Properties that come after the DER-encoded certificate will be silently ignored.  (This meant that our first try, which sorted Properties by ascending Property ID, didn’t work as intended, because the name constraint Property has a greater Property ID than the DER-encoded certificate.  Oops!)  Interestingly, Aerth was able to dig up a Microsoft documentation page indicating that listing any Properties after the certificate itself would yield undefined behavior.  I guess now we know what that undefined behavior is.&lt;/p&gt;

&lt;h2 id=&quot;editing-existing-blobs&quot;&gt;Editing Existing Blobs&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; was always a one-way thing: you put in the cert you want, and it spits out a Blob.  However, this is not really desirable for the purpose of applying an external name constraint, because we don’t want to overwrite the Properties that already exist in the certificate store.  (Many of them, e.g. EKU, are probably security-critical.)  So we added functionality to read an existing Blob from the cert store and use that as the starting point, instead of creating an empty Blob with just the DER-encoded certificate.&lt;/p&gt;

&lt;p&gt;This is not as complete as it could be.  In the future, we intend to support fine-grained editing within a Property, e.g. adding a domain name to the name constraints list without destroying the existing name constraints.&lt;/p&gt;

&lt;h2 id=&quot;searching-for-certificates-by-hash&quot;&gt;Searching for Certificates by Hash&lt;/h2&gt;

&lt;p&gt;Originally, &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; was designed to accept a certificate as input, and it would then calculate the SHA1 hash itself for use as a Windows registry key.  (Yes, Windows still uses SHA1 as a certificate identifier.  Yes, this is stupid.  No, it’s not our problem.)  This made sense when the intent was to inject a cert that previously didn’t exist in the cert store, but since we now want to use it to edit existing certs, there’s no reason to force the user to know the preimage.  &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; now allows the user to specify a SHA1 hash of a certificate, which will get passed through directly when constructing the registry key.  This makes things a lot easier, and also leads to the next item.&lt;/p&gt;

&lt;h2 id=&quot;applying-operations-store-wide&quot;&gt;Applying Operations Store-Wide&lt;/h2&gt;

&lt;p&gt;Our intent for external name constraints is to Constrain All The Things, i.e. we want &lt;strong&gt;all&lt;/strong&gt; built-in root CA’s to be prohibited from issuing certificates for &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; domains.  Put another way, for those of you who’ve worked with our NSS cross-signing tools, we want the UX to be more like &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrictnss&lt;/code&gt; and not &lt;code class=&quot;highlighter-rouge&quot;&gt;crosssignnameconstraint&lt;/code&gt;.  &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; can now crawl the list of all certificates in a given certificate store, and apply the specified EKU or name constraint operations to all of them.  For practical purposes, this would usually entail applying the name constraint to all certs in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Root&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; logical stores of the &lt;code class=&quot;highlighter-rouge&quot;&gt;System&lt;/code&gt; physical store.  Optionally, users might also want to apply the name constraint to the &lt;code class=&quot;highlighter-rouge&quot;&gt;Root&lt;/code&gt; logical store of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Enterprise&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Group-Policy&lt;/code&gt; physical stores.&lt;/p&gt;

&lt;p&gt;This is not quite as complete as it could be.  In the future, we intend to support tagging certificates with a “magic value”, which allows users to designate specific root CA’s that they want to exempt from the name constraint; &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; would then avoid applying the name constraint to those specific CA’s when doing a store-wide operation.  This could be used to allow users to deliberately run a MITM proxy on &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; traffic for diagnostic purposes, without losing protection from other root CA’s that the user doesn’t want to intercept &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; traffic.  (&lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; already has some skeleton support for magic values, which ncdns uses for cleaning up expired certificates for privacy purposes.  So this will not be hard to add.)&lt;/p&gt;

&lt;h2 id=&quot;adding-a-command-line-utility&quot;&gt;Adding a Command-line Utility&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; now can be built as a command-line &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject.exe&lt;/code&gt; utility, which facilitates users who want to use it as an alternative to &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; from the command-line.  It also supports both DER and PEM certficates, for maximal ease of use.&lt;/p&gt;

&lt;h2 id=&quot;adding-extensive-integration-tests&quot;&gt;Adding Extensive Integration Tests&lt;/h2&gt;

&lt;p&gt;Cirrus CI now tests &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; daily for a variety of use cases against a real TLS client in a real Windows VM.  This has already surfaced a few bugs (which we fixed), and also ensures that if Microsoft ships an update that changes the behavior we’re relying on, we will automatically get notified.&lt;/p&gt;

&lt;p&gt;An interesting issue that we encountered here was that Windows tends to cache TLS cert verification results, which caused integration tests to interfere with each other.  This caching is generally done on a per-process basis, so spawning a separate PowerShell process for each TLS handshake worked pretty well for avoiding this issue.  (An exception is that Windows has some kind of special caching mechanism for “revoked” status, which is not on a per-process basis.  This meant that our tests for the &lt;code class=&quot;highlighter-rouge&quot;&gt;Disallowed&lt;/code&gt; logical store needed to take extra precautions, specifically sleeping for 30 seconds between consecutive TLS handshakes, so that the cache would expire.  Yes, this is stupid.)&lt;/p&gt;

&lt;p&gt;Another more boring (yet also more amusing) issue we found is that our initial on-a-whim choice of using &lt;code class=&quot;highlighter-rouge&quot;&gt;github.com&lt;/code&gt; as a test case of a TLS cert that was publicly trusted backfired, because &lt;code class=&quot;highlighter-rouge&quot;&gt;github.com&lt;/code&gt; promptly blacklisted our CI VM for rate-limit violations, causing our tests to start failing nondeterministically as soon as we had more than a few test cases.  Oops.  We switched these tests to use &lt;code class=&quot;highlighter-rouge&quot;&gt;namecoin.org&lt;/code&gt;, which seems a tad more ethical, and all is okay now.&lt;/p&gt;

&lt;p&gt;We also did a bunch of code cleanup, based on feedback from static analyzers.&lt;/p&gt;

&lt;h2 id=&quot;so-whats-next&quot;&gt;So what’s next?&lt;/h2&gt;

&lt;p&gt;Stay tuned for a future post on how we’re going to integrate this new &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; functionality into Namecoin.&lt;/p&gt;
</description>
        <pubDate>Fri, 08 Jan 2021 00:00:00 +0000</pubDate>
        <link>https://www.namecoin.org/2021/01/08/external-name-constraints-in-certinject.html</link>
        <guid isPermaLink="true">https://www.namecoin.org/2021/01/08/external-name-constraints-in-certinject.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin Presentation at Grayhat 2020 Monero Village</title>
        <description>&lt;p&gt;I gave a talk on October 31, 2020, at the &lt;a href=&quot;https://grayhat.co/&quot;&gt;Grayhat 2020&lt;/a&gt; &lt;a href=&quot;https://monerovillage.org/&quot;&gt;Monero Village&lt;/a&gt;, entitled “Namecoin as a Decentralized Alternative to Certificate Authorities for TLS”.  A video recording is below:&lt;/p&gt;

&lt;video controls=&quot;&quot;&gt;
&lt;source src=&quot;https://www.namecoin.org/files/videos/grayhat-2020/Grayhat-2020-Namecoin.webm&quot; type=&quot;video/webm&quot; /&gt;
Video of &quot;Namecoin as a Decentralized Alternative to Certificate Authorities for TLS&quot; at Grayhat 2020.
&lt;/video&gt;

&lt;p&gt;Slides are here:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/resources/presentations/Grayhat_2020/Namecoin_TLS_Part_1_Grayhat_2020_Monero_Village.pdf&quot;&gt;Slides (Part 1)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/resources/presentations/Grayhat_2020/Namecoin_TLS_Part_2_Grayhat_2020_Monero_Village.pdf&quot;&gt;Slides (Part 2)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Huge thanks to Diego “rehrar” Salazar from Monero for inviting me!&lt;/p&gt;

&lt;p&gt;License information: Diego’s introduction in the video is under a CC-BY 4.0 license.&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
        <link>https://www.namecoin.org/2021/01/01/namecoin-at-grayhat-2020-monero-village.html</link>
        <guid isPermaLink="true">https://www.namecoin.org/2021/01/01/namecoin-at-grayhat-2020-monero-village.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin Will Present at Next Generation Internet Webinar on Naming Systems</title>
        <description>&lt;p&gt;I will present at the webinar &lt;a href=&quot;https://www.ngi.eu/event/ngi-projects-contribution-to-technological-developments-of-dns-and-naming-systems/?instance_id=423&quot;&gt;“Next Generation Internet projects’ contribution to technological developments of DNS and naming systems”&lt;/a&gt; hosted by NLnet Foundation.&lt;/p&gt;

&lt;p&gt;The presentation will cover work by Lola, yanmaani, and Ahmed.  It will be December 10, 2020, 2:00 pm – 4:00 pm CET, and should be open to the public &lt;a href=&quot;https://bbb.tbm.tudelft.nl/b/mic-hhp-gxg-uyc&quot;&gt;via NLnet Foundation&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Dec 2020 00:00:00 +0000</pubDate>
        <link>https://www.namecoin.org/2020/12/09/namecoin-will-present-at-ngi-webinar.html</link>
        <guid isPermaLink="true">https://www.namecoin.org/2020/12/09/namecoin-will-present-at-ngi-webinar.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin Core Name Renew GUI</title>
        <description>&lt;p&gt;Now that Namecoin Core’s &lt;a href=&quot;/2020/08/23/namecoin-core-name-list-gui.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_list&lt;/code&gt; GUI&lt;/a&gt; is merged to &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; branch (it’ll be in the v22.0 release!), it’s time to move on to renewing names.  As with the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_list&lt;/code&gt; GUI, I’m trying to follow the principles of (1) keeping PR’s small, and (2) keeping all the interesting logic in the RPC method rather than the GUI.&lt;/p&gt;

&lt;p&gt;In service of principle 1, I’m not touching the “Configure Name” GUI, nor am I touching the “Renew Name” button; this only adds the right-click context menu for renewing names.  In service of principle 2, yanmaani has done the excellent work of &lt;a href=&quot;/2020/12/04/namecoin-core-name-firstupdate-name-update-default-values.html&quot;&gt;adding a renew mode&lt;/a&gt; to the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; RPC method, which simplifies the GUI logic considerably.&lt;/p&gt;

&lt;p&gt;So, without further rambling, here are some screenshots:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/namecoin-core/name-renew-single-context-menu-2020-12-04.png&quot; alt=&quot;A screenshot of the Renew Names context menu in Namecoin-Qt.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/namecoin-core/name-renew-single-confirmation-2020-12-04.png&quot; alt=&quot;A screenshot of the Renew Names confirmation dialog in Namecoin-Qt.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/namecoin-core/name-renew-multiple-context-menu-2020-12-04.png&quot; alt=&quot;A screenshot of the Renew Names context menu for multiple names in Namecoin-Qt.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/namecoin-core/name-renew-multiple-confirmation-2020-12-04.png&quot; alt=&quot;A screenshot of the Renew Names confirmation dialog for multiple names in Namecoin-Qt.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Astute readers will have noticed that you can now renew multiple names at once, like in Electrum-NMC.  This was a minimal enough change from Brandon’s GUI that I figured I’d toss it in.&lt;/p&gt;

&lt;p&gt;Some more code review will be needed, but I don’t expect any major obstacles getting this merged.&lt;/p&gt;
</description>
        <pubDate>Sat, 05 Dec 2020 00:00:00 +0000</pubDate>
        <link>https://www.namecoin.org/2020/12/05/namecoin-core-name-renew-gui.html</link>
        <guid isPermaLink="true">https://www.namecoin.org/2020/12/05/namecoin-core-name-renew-gui.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin Core name_firstupdate, name_update default values</title>
        <description>&lt;p&gt;Namecoin Core will, starting version 0.21, no longer require for a value to be provided in the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; RPC calls. If no value is provided, Namecoin Core will use the last known such. If none exists, the empty string will be used. This change has no adverse impact on existing workflows, since it only makes previously required parameters optional. However, it does make it easier to update names. If no change in the value is desired, users will be able to directly issue an update for the name, without having to interrogate the present value with &lt;code class=&quot;highlighter-rouge&quot;&gt;name_show&lt;/code&gt;. This simplifies a common workflow.&lt;/p&gt;

&lt;p&gt;This change is being made as part of the effort to simplify the RPC API for name management.&lt;/p&gt;
</description>
        <pubDate>Fri, 04 Dec 2020 00:00:00 +0000</pubDate>
        <link>https://www.namecoin.org/2020/12/04/namecoin-core-name-firstupdate-name-update-default-values.html</link>
        <guid isPermaLink="true">https://www.namecoin.org/2020/12/04/namecoin-core-name-firstupdate-name-update-default-values.html</guid>
        <dc:creator>yanmaani</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Notes on building Python for Windows using RBM</title>
        <description>&lt;p&gt;Namecoin would like for Tor Browser to support .bit domains.  The only mature, lightweight way to do this is to use the wallet qua name resolver Electrum-NMC.  It is written in Python.  To run Python software, you need an interpreter, like CPython.&lt;/p&gt;

&lt;p&gt;Namecoin and Tor are both intended to be secure projects.  All their binaries have to build reproducibly.  The Tor Browser is also intended to be portable.  It’s not acceptable for users to have to install additional software on their computer to run Tor Browser.&lt;/p&gt;

&lt;p&gt;This means a Python interpreter would have to be bundled in order for Electrum-NMC to be includible in Tor Browser.  And since Tor Browser is a secure project, said Python interpreter has to be built reproducibly.  For this reason, the &lt;code class=&quot;highlighter-rouge&quot;&gt;tor-browser-build&lt;/code&gt; repository has received some patches to reproducibly build such binaries.&lt;/p&gt;

&lt;p&gt;This post details the problems encountered while making them.&lt;/p&gt;

&lt;p&gt;Building CPython reproducibly for Linux is trivial.  Download the source code, patch it to disable build timestamps, and compile.  That’s it, you’re done.&lt;/p&gt;

&lt;p&gt;The situation is markedly different on Windows.  The official Python documentation suggests &lt;a href=&quot;https://github.com/python/cpython/blob/master/PCbuild/readme.txt&quot;&gt;building with Microsoft Visual Studio 2017&lt;/a&gt;.  This is no good.  That compiler doesn’t support reproducible builds, it’s closed-source, and it would have to run in Wine.&lt;/p&gt;

&lt;p&gt;There should be another way.  CPython is written in standard C.  GCC can cross-compile C software for Windows using MinGW - the compiler runs on Linux, but produces binaries for Windows.  That’s how the Tor Project build Tor Browser for Windows.  In theory, it should be possible to use GCC to cross-compile CPython for Windows, and a lot of Tor’s tooling should be possible to re-use.&lt;/p&gt;

&lt;p&gt;In practice, Python’s ordinary build system doesn’t support this.  It isn’t made for cross-compilation.  Thankfully, one &lt;a href=&quot;https://github.com/erikjanss&quot;&gt;Erik Janssens&lt;/a&gt; had created an alternative &lt;a href=&quot;https://mesonbuild.com/&quot;&gt;Meson&lt;/a&gt;-based &lt;a href=&quot;https://github.com/v-finance/cross-python&quot;&gt;build script&lt;/a&gt; to compile Python for Windows with Linux using GCC and MinGW.  Many thanks!&lt;/p&gt;

&lt;p&gt;This build script needed some minor adaptations to properly integrate it with the Tor Project’s RBM build system.  Meson and RBM both have built-in features for dependency handling, such as downloading files from URLs, verifying their hashes, and caching them.  Doing this requires Internet access.  When compiling, RBM disables Internet access.&lt;/p&gt;

&lt;p&gt;The configuration script will thus have to download the binaries and move them into the cache directory used by Meson.  This change also makes the build faster - RBM uses a fresh VM for each build, so unless the cache is outside of the VM, it will be wiped on each new build.&lt;/p&gt;

&lt;p&gt;After this was done, RBM was able to produce something resembling a Python 3.8 interpreter.  However, it wasn’t functional.  Owing to what presumably was an idiosyncracy of the MinGW system, a critical library named &lt;code class=&quot;highlighter-rouge&quot;&gt;libwinpthread-1.dll&lt;/code&gt; wasn’t included.&lt;/p&gt;

&lt;p&gt;This problem turned out to be easy to fix.  Ruben Van Boxem, a contributor to the MinGW project, &lt;a href=&quot;https://stackoverflow.com/a/14033674&quot;&gt;suggested&lt;/a&gt; on StackOverflow that the compiler/linker simply be explicitly told to link this library statically.  This worked:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ wine python.exe
Python 3.8.5 (default, xx/xx/xx, xx:xx:xx) [gcc] on win32
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The changes are now submitted and subject to review.&lt;/p&gt;

&lt;p&gt;We think other projects that use Python might find these efforts useful.  In particular, upstream Electrum may benefit from using a reproducible build of Python.  We want to help others, so we try to submit patches and contribute where appropriate:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The RBM build descriptor carries a custom patch to omit build timestamps in CPython.  With this merged upstream, reproducible builds of CPython would become easier, and the maintenance burden lower.&lt;/li&gt;
  &lt;li&gt;I have submitted some &lt;a href=&quot;https://github.com/v-finance/cross-python/pull/1&quot;&gt;minor documentation changes&lt;/a&gt; for Mr. Janssens’s build script.&lt;/li&gt;
  &lt;li&gt;The RBM build descriptor can be used to build Python, without necessarily building the Tor Browser.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 21 Oct 2020 00:00:00 +0000</pubDate>
        <link>https://www.namecoin.org/2020/10/21/notes-on-building-python-for-windows-using-rbm.html</link>
        <guid isPermaLink="true">https://www.namecoin.org/2020/10/21/notes-on-building-python-for-windows-using-rbm.html</guid>
        <dc:creator>yanmaani</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Porting Namecoin in Tor Browser to Windows</title>
        <description>&lt;p&gt;As you no doubt remember &lt;a href=&quot;/2020/01/11/36c3-summary.html&quot;&gt;from 36C3&lt;/a&gt;, the GNU/Linux version of Tor Browser Nightly comes with Namecoin support included.  While we’ve received significant test feedback (overwhelmingly positive), it’s been pointed out that supporting Windows would enable additional test feedback, since not everyone has a GNU/Linux machine to test things on.  So, I’ve been porting the Namecoin support in Tor Browser Nightly to Windows.&lt;/p&gt;

&lt;h2 id=&quot;stemns-and-tor-bootstrap&quot;&gt;StemNS and Tor Bootstrap&lt;/h2&gt;

&lt;p&gt;First off, since this endeavor was going to involve some changes to StemNS, I figured this was a good opportunity to investigate an odd bug that was happening in StemNS sometimes.  I had noticed last year that in a fresh Tor Browser install, if Namecoin was enabled on the first run, Tor Launcher would indicate that Tor bootstrap had stalled at the “loading authority certificates” stage.  I found that spamming the Tor Launcher buttons to cancel and retry connecting would usually make the connection succeed after 5-10 tries, which seemed to suggest a race condition.  After quite a lot of manual inspection of StemNS logs, I found something odd.&lt;/p&gt;

&lt;p&gt;While the Tor control spec states that the &lt;code class=&quot;highlighter-rouge&quot;&gt;__LeaveStreamsUnattached&lt;/code&gt; config option will cause all streams to wait for the controller (StemNS in this case) to attach them, this was empirically not what was happening.  Rather, streams created as a result of user traffic (e.g. Firefox or Electrum-NMC) were waiting for StemNS to attach them, but streams created by Tor’s bootstrap were still automatically being attached.  The Tor control spec goes on to say the following:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Attempting to attach streams
via TC when “__LeaveStreamsUnattached” is false may cause a race between
Tor and the controller, as both attempt to attach streams to circuits.&lt;/p&gt;

  &lt;p&gt;You can try to attachstream to a stream that
has already sent a connect or resolve request but hasn’t succeeded
yet, in which case Tor will detach the stream from its current circuit
before proceeding with the new attach request.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This certainly explained what had been happening.  Tor was opening a stream to bootstrap (attaching the stream to a circuit in the process), and (depending on exact timing) StemNS was trying to attach it a 2nd time, which caused the stream to be detached, thus killing the bootstrap.&lt;/p&gt;

&lt;p&gt;At this point, I decided to ask the Tor developers whether this was a bug in the spec or the C implementation.  Roger Dingledine pointed me to the exact C code that handled this, which indicated exactly how StemNS could detect this case and handle it properly.  Roger also indicated that the C code was correct, and that the spec was incorrect.  I concurred that this made sense.&lt;/p&gt;

&lt;p&gt;I was then able to modify StemNS to handle this properly by detecting whether a new stream was created by user traffic or internal bootstrap, and only attaching streams from the former.  Testing confirmed that the bug was fixed.  Great, now let’s move on.&lt;/p&gt;

&lt;h2 id=&quot;exiting-namecoin-when-tor-browser-exits&quot;&gt;Exiting Namecoin when Tor Browser Exits&lt;/h2&gt;

&lt;p&gt;The existing Namecoin support in Tor Browser relies on a Bash script that signals Electrum-NMC and StemNS to exit after Firefox exits.  Alas, Bash is only used as a launcher in GNU/Linux, so I needed to port this to a more cross-platform approach.&lt;/p&gt;

&lt;p&gt;Tor Browser already solves this problem for the Tor daemon: Tor needs to exit when Firefox has done so.  Tor Browser does this by having Firefox send the &lt;code class=&quot;highlighter-rouge&quot;&gt;TAKEOWNERSHIP&lt;/code&gt; command to Tor, which instructs Tor to exit when Firefox closes the control port connection.  This inspired me to do something similar in StemNS: I added an event listener to StemNS that triggers when Tor closes the control port connection to StemNS (which will happen when Tor exits).  I configured the event listener to send an RPC &lt;code class=&quot;highlighter-rouge&quot;&gt;stop&lt;/code&gt; command to Electrum-NMC (which will make Electrum-NMC exit), and then exit StemNS as well.  (The latter took some DuckDuckGo-fu, as it turns out that &lt;code class=&quot;highlighter-rouge&quot;&gt;sys.exit()&lt;/code&gt; can’t be called from a child thread in Python; the correct way to exit from a child thread is &lt;code class=&quot;highlighter-rouge&quot;&gt;os._exit()&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Some testing revealed that this worked; I was able to remove the Bash code that terminated Electrum-NMC and StemNS, and they still exited properly.  Moving on…&lt;/p&gt;

&lt;h2 id=&quot;launching-namecoin-when-tor-browser-starts&quot;&gt;Launching Namecoin when Tor Browser Starts&lt;/h2&gt;

&lt;p&gt;Of course, the other part of the Bash launcher for Namecoin was the code that launches Electrum-NMC and StemNS.  For this, I ended up copying/pasting the code in Tor Launcher that launches the Tor daemon.  As XPCOM-based JavaScript code goes, Tor Launcher is pretty readable, so the copy/paste job wasn’t particularly eventful.  I &lt;em&gt;did&lt;/em&gt; notice that the documentation for debugging Tor Launcher was outdated, but the Tor developers on IRC were able to point me in the right direction there.&lt;/p&gt;

&lt;p&gt;I won’t bore you with too many details on this part; it was mostly grunt work.  But I got it working.  Excellent, moving on….&lt;/p&gt;

&lt;h2 id=&quot;windows-and-python&quot;&gt;Windows and Python&lt;/h2&gt;

&lt;p&gt;By this point, all of the GNU/Linux-specific code had been replaced with cross-platform code.  So we were ready to move onto enabling Windows support.  Most of this was as simple as tweaking the rbm descriptors to enable Namecoin on Windows, and fixing a few bugs where the Go dependencies for certain rbm projects were wrong on Windows.  But, there was one issue that needed dealing with: Python.&lt;/p&gt;

&lt;p&gt;Both Electrum-NMC and StemNS are written in Python.  GNU/Linux systems generally have Python available by default, but this is not the case for Windows.  In addition, on GNU/Linux, Python scripts are executable programs, but on Windows, they’re data files that need to be explicitly opened with the Python interpreter.  This means that some Windows-specific things need to be done.&lt;/p&gt;

&lt;p&gt;For Python being available, I took the easy way out: I simply defined [1] it to be out of scope, i.e. the user is responsible for installing Python themselves before enabling Namecoin in Tor Browser.  I also rigged Tor Launcher to check every directory in the &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; for a Python interpreter, and to use the discovered Python binary as the executable, passing the Electrum-NMC or StemNS path as a command-line argument instead.  Worked pretty well.&lt;/p&gt;

&lt;p&gt;Finally, I re-implemented verbose logging for Namecoin (which was also part of the Bash code that I had removed).  This was done via a &lt;code class=&quot;highlighter-rouge&quot;&gt;TOR_VERBOSE_NAMECOIN&lt;/code&gt; environment variable.  It does two things when enabled:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pass the &lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt; argument to Electrum-NMC, which enables verbose output.&lt;/li&gt;
  &lt;li&gt;On Windows, use &lt;code class=&quot;highlighter-rouge&quot;&gt;python.exe&lt;/code&gt; (which pops up a command prompt window with logs) instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;pythonw.exe&lt;/code&gt; (which doesn’t spawn a command window).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Oh, and I had to tweak the linker flags for &lt;code class=&quot;highlighter-rouge&quot;&gt;ncprop279&lt;/code&gt; to make it avoid launching a command prompt window on Windows as well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/tor/tor-browser-windows-2020-08-20.png&quot; alt=&quot;A screenshot of Namecoin in Tor Browser on Windows.&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;epilogue&quot;&gt;Epilogue&lt;/h2&gt;

&lt;p&gt;I sent in the code to the Tor Browser Team, and it’s now awaiting review.&lt;/p&gt;

&lt;p&gt;In the meantime, I noticed that the &lt;code class=&quot;highlighter-rouge&quot;&gt;__LeaveStreamsUnattached&lt;/code&gt; issue has a more correct fix now.  The master branch of Tor and Stem recently added a new stream status, &lt;code class=&quot;highlighter-rouge&quot;&gt;CONTROLLER_WAIT&lt;/code&gt;, which indicates specifically that a stream is now waiting for the controller to attach it.  Thus, I’ve updated StemNS to only check for this status, rather than the mildly-convoluted previously-existing method of guessing whether a stream was waiting for this.  That means StemNS’s master branch is now incompatible with Tor 0.4.5.0, Stem 1.8.0, and earlier.  I’ve tagged a stable release that doesn’t include this refactor, and if any important bugfixes make their way into StemNS before the new Tor and Stem behavior gets into releases, I’ll probably backport them to a stable branch.&lt;/p&gt;

&lt;p&gt;And now, we wait for code review from the Tor Browser Team.  Let the bikeshedding begin!&lt;/p&gt;

&lt;p&gt;This work was funded by Cyphrs and Cyberia Computer Club.&lt;/p&gt;

&lt;p&gt;[1] This is a totally legit usage of definitional discretion.  &lt;a href=&quot;https://old.reddit.com/r/Jokes/comments/77zo3h/an_engineer_a_physicist_and_a_mathematician_are/&quot;&gt;Really.&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 09 Oct 2020 00:00:00 +0000</pubDate>
        <link>https://www.namecoin.org/2020/10/09/porting-namecoin-in-tor-browser-to-windows.html</link>
        <guid isPermaLink="true">https://www.namecoin.org/2020/10/09/porting-namecoin-in-tor-browser-to-windows.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin Core name_list GUI</title>
        <description>&lt;p&gt;Namecoin Core’s name management GUI has always been a bit neglected.  While we do have a GUI that works reasonably well, it’s been stuck in an old branch that is nontrivial to forward-port.  The main reason that it’s been hard to maintain is that it depends on internal API’s that often get refactored, which breaks the GUI unless someone volunteers to constantly test the GUI whenever upstream refactors get merged (which is not a great use of anyone’s time).  GUI code is also hard to test on Travis CI compared to CLI-accessible code, which compounds the problem.&lt;/p&gt;

&lt;p&gt;Brandon accurately observed that a way to mitigate this issue is to expose all of the functionality that the GUI needs as RPC methods, and then simply make the GUI call RPC functions.  (Bitcoin Core includes a built-in API for internally calling RPC functions.)  This minimizes the amount of logic that the GUI needs to carry, which both enables integration testing and eliminates private API usage in the GUI code.  This was partially done in Brandon’s branch that was used for the name tab binaries that we released, but unfortunately, there was still some logic that needed internal API’s.&lt;/p&gt;

&lt;p&gt;So, I’m picking up where Brandon left off.  For one thing, I’m splitting the code into multiple PR’s, which can be merged independently: the GUI equivalents of &lt;code class=&quot;highlighter-rouge&quot;&gt;name_list&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;name_autoregister&lt;/code&gt;.  The first of these, &lt;code class=&quot;highlighter-rouge&quot;&gt;name_list&lt;/code&gt;, is used for displaying the current name inventory.  I’ve spent some time forward-porting the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_list&lt;/code&gt; GUI to current Namecoin Core, and here’s a preliminary result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/namecoin-core/manage-names-2020-08-19.png&quot; alt=&quot;A screenshot of the Manage Names tab in Namecoin-Qt.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There’s still some more code cleanup needed before it can be merged, but I’m optimistic that we can get a merge to happen soon.&lt;/p&gt;

</description>
        <pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate>
        <link>https://www.namecoin.org/2020/08/23/namecoin-core-name-list-gui.html</link>
        <guid isPermaLink="true">https://www.namecoin.org/2020/08/23/namecoin-core-name-list-gui.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin Core name_show name expiration</title>
        <description>&lt;p&gt;Namecoin Core will, starting version 0.21, change the default behavior of the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_show&lt;/code&gt; RPC API call in the presence of certain errors to better match the documentation, the behavior of Electrum-NMC, and the behavior expected by users.&lt;/p&gt;

&lt;p&gt;When Namecoin Core was first written, it exposed name resolution using an inconsistent API.
When querying for a name that was not active, the behavior varied by the history of the name.
If it had never been registered, Namecoin would return an error.
If it had once been registered in the past, but was now expired, Namecoin would return a response that was deceptively similar to that returned when querying for names that were still active.&lt;/p&gt;

&lt;p&gt;Owing to this inconsistency, some applications using Namecoin Core came to treat expired names as if they were still active.
This was a security problem.
Users continued to use services identified by the names as usual, and as such their operators did not re-register them, but Namecoin does not afford unregistered names any protection.
Therefore, anyone could have registered the names, thereby hijacking the services.
While this may be considered immaterial, it is our opinion that Namecoin should not indirectly encourage such dangerous use-cases.&lt;/p&gt;

&lt;p&gt;Furthermore, those applications’ use of the API for this purpose was incorrect.
Expired names should not be considered alive, and it can hardly be thought that considering them as such would have been the intent in implementing it.
A programmer who relied solely on the documentation (“Looks up the current data for the given name. Fails if the name doesn’t exist.”) would not be left with the impression that the operation would, in fact, only fail for never-registered names.&lt;/p&gt;

&lt;p&gt;For these reasons, a change to the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_show&lt;/code&gt; API in Namecoin Core has been made.
&lt;code class=&quot;highlighter-rouge&quot;&gt;name_show&lt;/code&gt; will now by default throw an error when attempting to resolve an expired name.
This brings the default behavior in line with Electrum-NMC, which has always thrown an error.
The old behavior can be preserved by setting the allowExpired option or -allow_expired command-line parameter to true.
There are presently no plans to deprecate these flags.&lt;/p&gt;

&lt;p&gt;This change will be included in version 0.21 of Namecoin Core.
Downstream users who use &lt;code class=&quot;highlighter-rouge&quot;&gt;name_show&lt;/code&gt; to resolve names for user-facing purposes should not need to make any changes to their usage.
Downstream users who use &lt;code class=&quot;highlighter-rouge&quot;&gt;name_show&lt;/code&gt; to resolve names, but who would also like to distinguish between names that have expired and names that have never been registered, are encouraged to explore the allowExpired field in the JSON RPC options argument and the -allowexpired command line parameter.
In such cases, the old behavior still applies, whereby downstream users are expected to consider the value of the &lt;code class=&quot;highlighter-rouge&quot;&gt;expired&lt;/code&gt; field to ascertain whether a domain has expired.&lt;/p&gt;

&lt;p&gt;This change does not affect the resolution of active names in any way.
This change does not affect the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_history&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;name_scan&lt;/code&gt; RPC calls.
This change does not affect Electrum-NMC.&lt;/p&gt;
</description>
        <pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate>
        <link>https://www.namecoin.org/2020/08/22/namecoin-core-name-show-expiration.html</link>
        <guid isPermaLink="true">https://www.namecoin.org/2020/08/22/namecoin-core-name-show-expiration.html</guid>
        <dc:creator>yanmaani</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
  </channel>
</rss>
