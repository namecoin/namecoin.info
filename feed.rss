<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Namecoin</title>
    <description><!--Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
--></description>
    <link>http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/</link>
    <atom:link href="http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/feed.rss" rel="self" type="application/rss+xml" />
    <language>en</language>
    <pubDate>Tue, 20 Apr 2021 09:48:33 +0000</pubDate>
    <lastBuildDate>Tue, 20 Apr 2021 09:48:33 +0000</lastBuildDate>
    <generator>Jekyll</generator>
    <image>
      <url>http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/images/logo.png</url>
      <title>Namecoin</title>
      <link>http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/</link>
      <width>134</width>
      <height>25</height>
    </image>
    
      <item>
        <title>Namecoin Released 10 Years Ago Today</title>
        <description>&lt;p&gt;Today, April 18, 2021, marks 10 years since Vincent Durham first released Namecoin.  We’d like to wish a very happy birthday to the Namecoin community, and we look forward to the next 10 years (and beyond) of hijacking-resistant, censorship-resistant naming and PKI.&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate>
        <link>http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/04/18/namecoin-released-10-years-ago-today.html</link>
        <guid isPermaLink="true">http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/04/18/namecoin-released-10-years-ago-today.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>ncdns v0.1.2 Released</title>
        <description>&lt;p&gt;We’ve released ncdns v0.1.2 for Windows.  This release includes a fix for an upstream issue that impacted Windows service support.  Binaries for non-Windows platforms are not yet available; we expect to release those soon.&lt;/p&gt;

&lt;p&gt;Full changelog of what’s new since v0.1:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DNS:
    &lt;ul&gt;
      &lt;li&gt;Fix caching bug that affected DS, SRV, MX, and non-dehydrated TLSA records.  Patch by Jeremy Rand.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TLS:
    &lt;ul&gt;
      &lt;li&gt;Compressed ECDSA public keys are now supported in TLSA records, even for TLS implementations that do not support such keys.  This paves the way for decreased blockchain storage.   Namecoin patch by Jeremy Rand; thanks to Filippo Valsorda for implementing this in upstream Go.&lt;/li&gt;
      &lt;li&gt;Add &lt;code class=&quot;highlighter-rouge&quot;&gt;aia.x--nmc.bit&lt;/code&gt; meta-domain.  This paves the way for layer-2 TLS; see my Grayhat 2020 presentation for details.  Patch by Jeremy Rand.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Windows:
    &lt;ul&gt;
      &lt;li&gt;Support logging to Windows Event Log.  Patch by Jeremy Rand; merged by Hugo Landau.&lt;/li&gt;
      &lt;li&gt;Switch to Windows Service library from upstream Go instead of abandoned Conformal fork.  This fixes a crash bug on Windows 10 when running as a Windows Service with ASLR/PIE enabled.  Patch by Jeremy Rand; merged by Hugo Landau.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Misc:
    &lt;ul&gt;
      &lt;li&gt;Code quality improvements.  Patches by Jeremy Rand.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Build system:
    &lt;ul&gt;
      &lt;li&gt;Support Go modules.  Patch by Jeremy Rand; thanks to Hugo Landau for valuable input.&lt;/li&gt;
      &lt;li&gt;Code quality improvements.  Patches by Jeremy Rand.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As usual, you can download it at the &lt;a href=&quot;/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/download/betas/#ncdns&quot;&gt;Beta Downloads page&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate>
        <link>http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/03/11/ncdns-v0.1.2-released.html</link>
        <guid isPermaLink="true">http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/03/11/ncdns-v0.1.2-released.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>Releases</category>
        
        <category>ncdns Releases</category>
        
        
      </item>
    
      <item>
        <title>Namecoin Core 0.21.0.1 Released</title>
        <description>&lt;p&gt;Namecoin Core 0.21.0.1 has been released on the &lt;a href=&quot;/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/download/#namecoin-core-client-stable-release&quot;&gt;Downloads page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here’s what’s new since 0.19.0.1:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_show&lt;/code&gt; for expired names will error by default.  (Reported by Jeremy Rand; Patch by Yanmaani; Reviewed by Daniel Kraft.)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_show&lt;/code&gt; can accept queries by SHA256d hash.  (Reported by Jeremy Rand; Patch by Daniel Kraft; Reviewed by Jeremy Rand.)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; now consider the value to be optional.  (Reported by Jeremy Rand; Patch by Yanmaani; Reviewed by Daniel Kraft.)&lt;/li&gt;
  &lt;li&gt;Added &lt;code class=&quot;highlighter-rouge&quot;&gt;namepsbt&lt;/code&gt; RPC method.  (Reported by Jeremy Rand; Patch by Daniel Kraft.)&lt;/li&gt;
  &lt;li&gt;Added new DNS seed for testnet.  (Patch by Yanmaani; Reviewed by Daniel Kraft.)&lt;/li&gt;
  &lt;li&gt;Fix build for WSL.  (Patch by Chris Andrew; Reviewed by Daniel Kraft.)&lt;/li&gt;
  &lt;li&gt;Fix crash on macOS 10.13+.  (Reported by Jip; Analysis by Jip, Daniel Kraft, Andy Colosimo, and Cassini; Patch by DeckerSU; Reviewed by Daniel Kraft.)&lt;/li&gt;
  &lt;li&gt;Code quality improvements for regression tests.  (Patch by Daniel Kraft.)&lt;/li&gt;
  &lt;li&gt;Numerous improvements from upstream Bitcoin Core.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 07 Mar 2021 00:00:00 +0000</pubDate>
        <link>http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/03/07/namecoin-core-0.21.0.1-released.html</link>
        <guid isPermaLink="true">http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/03/07/namecoin-core-0.21.0.1-released.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>Releases</category>
        
        <category>Namecoin Core Releases</category>
        
        
      </item>
    
      <item>
        <title>Nightly Builds of ncdns and certinject</title>
        <description>&lt;p&gt;The &lt;a href=&quot;/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/download/betas/&quot;&gt;Beta Downloads page&lt;/a&gt; now includes Nightly builds of ncdns (both the plain binaries and the Windows installer) and certinject.  For the #reckless among you who want to help us test new features or identify bugs before a release, the Nightly builds are a great way to do so.&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Mar 2021 00:00:00 +0000</pubDate>
        <link>http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/03/04/nightly-builds-ncdns-certinject.html</link>
        <guid isPermaLink="true">http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/03/04/nightly-builds-ncdns-certinject.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin Core Name Update GUI</title>
        <description>&lt;p&gt;Now that Namecoin Core’s &lt;a href=&quot;/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2020/12/05/namecoin-core-name-renew-gui.html&quot;&gt;Name Renewal GUI&lt;/a&gt; is complete (it’s been merged and will be in Namecoin Core v22.0), it’s time to move on to the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; GUI.  This forward-port was pretty uneventful, so rather than boring you with details, here’s a screenshot:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/images/screenshots/namecoin-core/name-update-2021-01-17.png&quot; alt=&quot;A screenshot of the Update Name dialog in Namecoin-Qt.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Code review will be needed before a merge can happen, but I expect the review process to be pretty uneventful as well.&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate>
        <link>http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/02/16/namecoin-core-name-update-gui.html</link>
        <guid isPermaLink="true">http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/02/16/namecoin-core-name-update-gui.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>ncdns v0.1 Released</title>
        <description>&lt;p&gt;We’ve released ncdns v0.1 for Windows.  The big new feature is system-wide TLS support on Windows.  Now any application that uses Windows for certificate verification (no longer just Chromium) will accept Namecoin TLS certificates, and will reject malicious certificates issued by public CA’s for Namecoin domains.  Note that some Windows software, such as Firefox, does not use the Windows certificate verifier, and is therefore not supported by this feature.&lt;/p&gt;

&lt;p&gt;Binaries for non-Windows platforms are not yet available; we expect to release those soon.&lt;/p&gt;

&lt;p&gt;Full changelog of what’s new since v0.0.10.3:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TLS:
    &lt;ul&gt;
      &lt;li&gt;Negative overrides are now supported for CryptoAPI (patches by Jeremy Rand).&lt;/li&gt;
      &lt;li&gt;Remove negative override support for Chromium (patches by Jeremy Rand).&lt;/li&gt;
      &lt;li&gt;Switch from x509-signature-splice to splicesign (patches by Jeremy Rand, thanks to Filippo Valsorda for the suggestion).&lt;/li&gt;
      &lt;li&gt;Code quality improvements (patches by Jeremy Rand).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Build system:
    &lt;ul&gt;
      &lt;li&gt;Fix silent NSIS installation (patches by Jeremy Rand).&lt;/li&gt;
      &lt;li&gt;Support NSIS install.log (patches by Jeremy Rand).&lt;/li&gt;
      &lt;li&gt;Code quality improvements (patches by Jeremy Rand)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As usual, you can download it at the &lt;a href=&quot;/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/download/betas/#ncdns&quot;&gt;Beta Downloads page&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
        <link>http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/02/05/ncdns-v0.1-released.html</link>
        <guid isPermaLink="true">http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/02/05/ncdns-v0.1-released.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>Releases</category>
        
        <category>ncdns Releases</category>
        
        
      </item>
    
      <item>
        <title>CTLPop: Populating the Windows AuthRoot Certificate Store</title>
        <description>&lt;p&gt;In my &lt;a href=&quot;/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/01/15/external-name-constraints-in-certinject.html&quot;&gt;previous post&lt;/a&gt;, I introduced improvements to &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt;, which allow us to apply a name constraint to all certificates in a Windows certificate store, without needing Administrator privileges.  Alas, there is a major issue with using &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; as presented in that post.  The issue is that most of the built-in root CA’s in Windows &lt;em&gt;aren’t part of any cert store!&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;wait-what&quot;&gt;Wait, What?&lt;/h2&gt;

&lt;p&gt;Yep.  Allow me to explain.  The root CA list in Windows is pretty large (420 root CA’s at the moment, if my count is correct), and can also be updated on the fly via Windows Update.  However, due to what Microsoft claims are performance concerns, only 24 of those root CA’s are actually populated in the cert store on a fresh Windows installation.  The full list lives in a file called &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot.stl&lt;/code&gt;, which ships with Windows, and can also be updated via Windows Update.  This file is a &lt;em&gt;CTL&lt;/em&gt; (certificate trust list), meaning it only stores the hashes of the certificates (and a bit of other metadata), not the certificate preimages.  (Why does a “CTL” have the file extension &lt;code class=&quot;highlighter-rouge&quot;&gt;.stl&lt;/code&gt; rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;.ctl&lt;/code&gt;?  Don’t ask.  Just accept that Microsoft hates you.  It’ll be easier that way.)  When Windows tries to verify a certificate that chains back to a certificate in &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot.stl&lt;/code&gt; but isn’t in the Windows certificate store, it automatically fetches the certificate preimage from Windows Update, and inserts it into the certificate store (typically in the &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; logical store) prior to proceeding with the verification.  This is all transparent to the user under typical circumstances.&lt;/p&gt;

&lt;p&gt;Personally I am highly dubious that this is a meaningful performance optimization, especially since this system was created (AFAICT) around 2 decades ago, so even if it helped performance when it was introduced, I doubt that this performance gain is applicable on modern hardware (especially since today, network latency is a much bigger contributor to perceived performance than any kind of local CPU or IO performance, and this system entails extra network latency when verifying certificates with a previously-unseen root CA).&lt;/p&gt;

&lt;h2 id=&quot;so-whats-the-problem&quot;&gt;So What’s the Problem?&lt;/h2&gt;

&lt;p&gt;Well, unfortunately, if a root CA is being downloaded on-the-fly during certificate verification, that prevents &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; from applying a name constraint to it before it gets used.  This is unfortunate, since it means that most of the root CA’s in Windows cannot be reliably constrained via &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-can-we-do&quot;&gt;What Can We Do?&lt;/h2&gt;

&lt;p&gt;It’s entirely feasible to download the full list of certificate preimages that &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot.stl&lt;/code&gt; refers to.  There’s even a mostly-undocumented [1] &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/dn265983(v=ws.11)#new-certutil-options&quot;&gt;command&lt;/a&gt; for this.  But what do we want to do with it?  Two ideas occurred to me:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We could download the full set of certs in SST (serialized store) format (which also includes all the metadata, i.e. Properties besides the cert preimage), and ask &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; to import it to the &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; logical store.  Unfortunately, this means we’d need to run as Administrator, which is not really ideal.  Also, how do we know for sure that &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; is the right logical store to import them?  Seems suboptimal.&lt;/li&gt;
  &lt;li&gt;We could download the full set of certs to individual files, and use &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; to individually inject them to the &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; store, with Properties manually parsed from the &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot.stl&lt;/code&gt; file.  While this does avoid running with Administrator privileges by virtue of using &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt;, it means we’d have to carefully parse the Properties from &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot.stl&lt;/code&gt;, and make sure that &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; is applying them correctly.  Seems like a lot of attack surface.  Also, we still don’t know for sure that they all belong in the &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; logical store, and it still requires write privileges to the &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; store’s registry key.  So this is still not great.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Since neither of these jumped out at me as “obviously this is the right way to do it”, I came up with another idea.&lt;/p&gt;

&lt;h2 id=&quot;make-windows-do-our-job-for-us&quot;&gt;Make Windows Do Our Job For Us!&lt;/h2&gt;

&lt;p&gt;If you were reading the first section of this post carefully, you might have noted that Windows itself will happily insert the certificates from &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot.stl&lt;/code&gt; into the certificate store under certain circumstances, specifically when it’s necessary for certificate verification.  Hmm, this sounds like something we can abuse!  What happens if we download the full set of certificates to individual files from Windows Update, and then just politely ask &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; to &lt;strong&gt;verify&lt;/strong&gt; all of them?  Intuitively, this seems like the kind of thing that will cause the following Series of &lt;del&gt;un&lt;/del&gt;Fortunate Events:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CryptoAPI tries to verify the certificate by chaining it to a root CA in the certificate store.  This, naturally, fails.&lt;/li&gt;
  &lt;li&gt;CryptoAPI checks whether the certificate chains to a root CA in &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot.stl&lt;/code&gt;.  Yes, the certificate does claim to be issued by a root CA in &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot.stl&lt;/code&gt;.  (In reality, that’s because the certificate is issued by &lt;strong&gt;itself&lt;/strong&gt;, but CryptoAPI can’t know this until it sees the issuing certificate.)&lt;/li&gt;
  &lt;li&gt;CryptoAPI helpfully fetches the root CA referenced by &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot.stl&lt;/code&gt; from Windows Update, and adds it to the certificate store.  &lt;strong&gt;Yay, we’ve achieved our goal!&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;CryptoAPI discovers that the certificate we’re trying to verify is now marked as trusted, and &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; tells us that verification succeeded.  That’s cool and such, but we don’t really care about this step.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And the beauty of this trick is that we don’t need &lt;strong&gt;any&lt;/strong&gt; elevated permissions for the certificate store (all we did was ask Windows to verify some certificates, which is obviously an unprivileged operation; Windows messed with the certificate store for us), nor did we need to worry about the Property metadata (again, Windows does this for us; there’s nothing we can screw up there no matter how buggy our code is).&lt;/p&gt;

&lt;p&gt;And indeed, based on testing, the above workflow works exactly as I was hoping it would!  Running &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; to verify a certificate in &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot.stl&lt;/code&gt; downloaded from Windows Update does indeed result in the certificate being immediately imported to the certificate store.  How cool is that?&lt;/p&gt;

&lt;p&gt;(Side note: it turns out I was absolutely right to be wary of assuming that the &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; logical store is the right place.  In fact, the &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot.stl&lt;/code&gt; CTL also covers a small number of Microsoft-operated root CA’s, which go in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Root&lt;/code&gt; logical store – &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; is only for built-in root CA’s &lt;strong&gt;not&lt;/strong&gt; operated by Microsoft.)&lt;/p&gt;

&lt;h2 id=&quot;ctlpop-the-authroot-certificate-trust-list-populator&quot;&gt;CTLPop: the AuthRoot Certificate Trust List Populator&lt;/h2&gt;

&lt;p&gt;I’ve created a simple PowerShell script called CTLPop, which automates this procedure.  Just create a temporary directory (e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;.\place-to-store-certs&lt;/code&gt;) to download certificates to, run &lt;code class=&quot;highlighter-rouge&quot;&gt;ctlpop.ps1 -sync_dir .\place-to-store-certs&lt;/code&gt;, wait a few minutes (Travis CI indicates that it takes 4 minutes and 26 seconds to run twice in a row on their VM), and voila: now all 420 of the built-in root CA’s are part of your certificate store, ready for you to apply name constraints via &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt;!&lt;/p&gt;

&lt;h2 id=&quot;so-whats-next&quot;&gt;So What’s Next?&lt;/h2&gt;

&lt;p&gt;The easiest way to use CTLPop and &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; is to simply run CTLPop once as part of the ncdns NSIS installer, and then run &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; to apply the name constraint globally (again, as part of the NSIS installer).  This is probably what we’ll ship initially, since it’s very simple and mostly works fine.  However, it’s not great in terms of sandboxing (the NSIS installer runs as Administrator), and it’s also not as robust as I’d like (because if Microsoft updates the &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot.stl&lt;/code&gt; list later, the new root CA’s won’t get the name constraint unless ncdns is reinstalled).  The “right” way to do this is to have a daemon that continuously watches for &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot.stl&lt;/code&gt; updates,  and runs CTLPop and &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; whenever an update is observed.  We could even add a dead-man’s switch to make ncdns automatically stop resolving &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; domains if the &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot.stl&lt;/code&gt;-watching daemon encounters some kind of unexpected error.  We’ll probably migrate to this approach in the future, since it’s much more friendly to sandboxing (CTLPop, which involves network access and parsing untrusted data via &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt;, can run completely unprivileged, and &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt;, which does not touch the network and doesn’t parse untrusted data, only needs read+write privileges to the &lt;code class=&quot;highlighter-rouge&quot;&gt;Root&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; certificate stores), and also will handle new root CA’s gracefully.&lt;/p&gt;

&lt;p&gt;Expect to see name constraints via CTLPop and &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; coming soon to an ncdns for Windows installer near you!&lt;/p&gt;

&lt;h2 id=&quot;epilogue&quot;&gt;Epilogue&lt;/h2&gt;

&lt;p&gt;After this post was written, but before publication, I discovered that &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; actually has a built-in command that will do exactly the same thing as CTLPop: &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil -v -f -verifyCTL AuthRootWU&lt;/code&gt;.  So, we can scrap the custom PowerShell implementation I wrote.  Everything else, e.g. integration with the ncdns NSIS installer, remains the same.  Why publish this post anyway?  Because research isn’t always as clean as people sometimes imagine it to be.  Researchers often pursue suboptimal leads; I think it’s useful to document the research process authentically rather than perpetuate the myth that scientists always know what they’re going to find in advance.&lt;/p&gt;

&lt;p&gt;[1] It’s not documented at &lt;a href=&quot;https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/certutil&quot;&gt;the certutil manual&lt;/a&gt;, but is mentioned elsewhere on Microsoft’s website.&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Feb 2021 00:00:00 +0000</pubDate>
        <link>http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/02/02/ctlpop-populating-windows-authroot-certificate-store.html</link>
        <guid isPermaLink="true">http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/02/02/ctlpop-populating-windows-authroot-certificate-store.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>External Name Constraints in certinject</title>
        <description>&lt;p&gt;In my &lt;a href=&quot;/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/01/14/undocumented-windows-feature-external-name-constraints.html&quot;&gt;previous post&lt;/a&gt;, I introduced the undocumented Windows feature for external name constraints, which allow us to apply a name constraint without the consent of a CA, and without needing to cross-sign the CA.  I mentioned that the Windows utility &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; can be tricked into setting this Property on a certificate using the &lt;code class=&quot;highlighter-rouge&quot;&gt;-repairstore&lt;/code&gt; command.  Alas, abusing &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; to do this comes with some problems:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;-repairstore&lt;/code&gt; command looks suspiciously like it’s intended to be used for totally different purposes, and I simply do not trust it to only set a name constraint and nothing else.&lt;/li&gt;
  &lt;li&gt;Using &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; to edit a public CA requires Administrator privileges, which is not great from a sandboxing perspective.&lt;/li&gt;
  &lt;li&gt;We’d ideally like to apply the name constraint to &lt;em&gt;all&lt;/em&gt; of the root CA’s in the certificate store, not just a single one.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; API doesn’t exactly make this &lt;em&gt;impossible&lt;/em&gt;, but the UX is a lot worse than, say, the &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrictnss&lt;/code&gt; tool I wrote that does something comparable for the NSS TLS library.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Those of you who’ve looked at the ncdns source code will recall that ncdns includes a library called &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt;, which is designed to interact with Windows cert stores without needing Administrator privileges.  Since &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; isn’t free software, but &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; is, and &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; already solves the privilege issue for us, Aerth and I have been extending &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; to do what’s needed for external name constraints.&lt;/p&gt;

&lt;h2 id=&quot;injecting-to-arbitrary-cert-stores&quot;&gt;Injecting to Arbitrary Cert Stores&lt;/h2&gt;

&lt;p&gt;The original &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; code only could write to the &lt;code class=&quot;highlighter-rouge&quot;&gt;Root&lt;/code&gt; logical cert store in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Enterprise&lt;/code&gt; physical cert store.  This is where root CA’s added by the system administrator would, by convention, be stored.  This is fine for &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt;’s original purpose of injecting self-signed certs for Namecoin websites, but all the CA’s we want to apply a name constraint to are elsewhere: generally in either the &lt;code class=&quot;highlighter-rouge&quot;&gt;Root&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; logical cert store in the &lt;code class=&quot;highlighter-rouge&quot;&gt;System&lt;/code&gt; physical cert store.  (&lt;code class=&quot;highlighter-rouge&quot;&gt;Root&lt;/code&gt; is where the Microsoft root CA’s live; &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; is where the root CA’s run by non-Microsoft corporations live.)  &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; can now inject certs into arbitrary logical stores (including the &lt;code class=&quot;highlighter-rouge&quot;&gt;Disallowed&lt;/code&gt; logical store, which is used to mark a certificate as revoked), and now supports the &lt;code class=&quot;highlighter-rouge&quot;&gt;System&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Group-Policy&lt;/code&gt; physical stores in addition to the previously supported &lt;code class=&quot;highlighter-rouge&quot;&gt;Enterprise&lt;/code&gt; physical store.&lt;/p&gt;

&lt;h2 id=&quot;serializing-properties&quot;&gt;Serializing Properties&lt;/h2&gt;

&lt;p&gt;Originally, &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; only serialized Blobs that included the DER-encoded certificate, with no other Properties set.  This worked fine for its original purpose, but we needed to make it more flexible.  &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; can now serialize Blobs with arbitrary Properties set.  &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt;’s list of Properties supported by Windows is generated (to Go source code) via a Bash script (lots of &lt;code class=&quot;highlighter-rouge&quot;&gt;grep&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sed&lt;/code&gt;) using the &lt;code class=&quot;highlighter-rouge&quot;&gt;wincrypt.h&lt;/code&gt; file from ReactOS as input.  Curiously, &lt;code class=&quot;highlighter-rouge&quot;&gt;wincrypt.h&lt;/code&gt; only seems to contain the Properties supported by Windows XP.  A bunch of extra Properties were added in Windows Vista, but these are only listed in another header file, &lt;code class=&quot;highlighter-rouge&quot;&gt;certenroll.h&lt;/code&gt;, which does not appear to exist in the ReactOS source code yet.  At the moment, we don’t have any urgent need for the Vista Properties, so we’re sticking with the ReactOS header file for maximum free-software-ness.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; can also now generate the binary data for Properties involving either EKU (extended key usage) or name constraints.  The Golang standard library doesn’t exactly make this easy; we settled on the approach of setting the EKU or name constraint fields in an &lt;code class=&quot;highlighter-rouge&quot;&gt;x509.Certificate&lt;/code&gt; template, serializing the entire certificate, deserializing the result back to a template, and searching the template’s list of parsed &lt;code class=&quot;highlighter-rouge&quot;&gt;Extensions&lt;/code&gt; for something that matched the OID of either EKU or name constraints.  A tad inefficient, but this approach does seem to maximize the usage of stable, production-grade standard library API’s compared to custom parsing code on our end, so I think it’s safer than trying to roll our own super-efficient implementation.&lt;/p&gt;

&lt;p&gt;While I was writing the EKU serialization code, I noticed that the Go standard library supports two EKU values that I had never heard of: &lt;code class=&quot;highlighter-rouge&quot;&gt;ExtKeyUsageMicrosoftServerGatedCrypto&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ExtKeyUsageNetscapeServerGatedCrypto&lt;/code&gt;.  Some DDG-ing revealed that these are a historical relic of 1990’s-era export-grade cryptography (also referred to as “International Step-Up”).  In particular, I found a Mozilla Bugzilla bug indicating that modern TLS implementations still support these 1990’s-era abominations because there exist public CA certs that rely on those particular EKU values, which didn’t expire until 2020.  I decided to explicitly not support these EKU values in &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt;; users who desire to see some mildly more colorful language describing my opinion of this functionality can grep the &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; source code for “beehive”.&lt;/p&gt;

&lt;p&gt;We intend to add support for more Properties later; there are several other Properties that have caught our eye, although they’re not a very high priority for us right now.&lt;/p&gt;

&lt;p&gt;The only other notable issue we encountered in Blob serialization is that we found experimentally that the Property containing the DER-encoded certificate &lt;strong&gt;must&lt;/strong&gt; be the final Property in the serialized Blob.  Any Properties that come after the DER-encoded certificate will be silently ignored.  (This meant that our first try, which sorted Properties by ascending Property ID, didn’t work as intended, because the name constraint Property has a greater Property ID than the DER-encoded certificate.  Oops!)  Interestingly, Aerth was able to dig up a Microsoft documentation page indicating that listing any Properties after the certificate itself would yield undefined behavior.  I guess now we know what that undefined behavior is.&lt;/p&gt;

&lt;h2 id=&quot;editing-existing-blobs&quot;&gt;Editing Existing Blobs&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; was always a one-way thing: you put in the cert you want, and it spits out a Blob.  However, this is not really desirable for the purpose of applying an external name constraint, because we don’t want to overwrite the Properties that already exist in the certificate store.  (Many of them, e.g. EKU, are probably security-critical.)  So we added functionality to read an existing Blob from the cert store and use that as the starting point, instead of creating an empty Blob with just the DER-encoded certificate.&lt;/p&gt;

&lt;p&gt;This is not as complete as it could be.  In the future, we intend to support fine-grained editing within a Property, e.g. adding a domain name to the name constraints list without destroying the existing name constraints.&lt;/p&gt;

&lt;h2 id=&quot;searching-for-certificates-by-hash&quot;&gt;Searching for Certificates by Hash&lt;/h2&gt;

&lt;p&gt;Originally, &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; was designed to accept a certificate as input, and it would then calculate the SHA1 hash itself for use as a Windows registry key.  (Yes, Windows still uses SHA1 as a certificate identifier.  Yes, this is stupid.  No, it’s not our problem.)  This made sense when the intent was to inject a cert that previously didn’t exist in the cert store, but since we now want to use it to edit existing certs, there’s no reason to force the user to know the preimage.  &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; now allows the user to specify a SHA1 hash of a certificate, which will get passed through directly when constructing the registry key.  This makes things a lot easier, and also leads to the next item.&lt;/p&gt;

&lt;h2 id=&quot;applying-operations-store-wide&quot;&gt;Applying Operations Store-Wide&lt;/h2&gt;

&lt;p&gt;Our intent for external name constraints is to Constrain All The Things, i.e. we want &lt;strong&gt;all&lt;/strong&gt; built-in root CA’s to be prohibited from issuing certificates for &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; domains.  Put another way, for those of you who’ve worked with our NSS cross-signing tools, we want the UX to be more like &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrictnss&lt;/code&gt; and not &lt;code class=&quot;highlighter-rouge&quot;&gt;crosssignnameconstraint&lt;/code&gt;.  &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; can now crawl the list of all certificates in a given certificate store, and apply the specified EKU or name constraint operations to all of them.  For practical purposes, this would usually entail applying the name constraint to all certs in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Root&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthRoot&lt;/code&gt; logical stores of the &lt;code class=&quot;highlighter-rouge&quot;&gt;System&lt;/code&gt; physical store.  Optionally, users might also want to apply the name constraint to the &lt;code class=&quot;highlighter-rouge&quot;&gt;Root&lt;/code&gt; logical store of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Enterprise&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Group-Policy&lt;/code&gt; physical stores.&lt;/p&gt;

&lt;p&gt;This is not quite as complete as it could be.  In the future, we intend to support tagging certificates with a “magic value”, which allows users to designate specific root CA’s that they want to exempt from the name constraint; &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; would then avoid applying the name constraint to those specific CA’s when doing a store-wide operation.  This could be used to allow users to deliberately run a MITM proxy on &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; traffic for diagnostic purposes, without losing protection from other root CA’s that the user doesn’t want to intercept &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; traffic.  (&lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; already has some skeleton support for magic values, which ncdns uses for cleaning up expired certificates for privacy purposes.  So this will not be hard to add.)&lt;/p&gt;

&lt;h2 id=&quot;adding-a-command-line-utility&quot;&gt;Adding a Command-line Utility&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; now can be built as a command-line &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject.exe&lt;/code&gt; utility, which facilitates users who want to use it as an alternative to &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; from the command-line.  It also supports both DER and PEM certficates, for maximal ease of use.&lt;/p&gt;

&lt;h2 id=&quot;adding-extensive-integration-tests&quot;&gt;Adding Extensive Integration Tests&lt;/h2&gt;

&lt;p&gt;Cirrus CI now tests &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; daily for a variety of use cases against a real TLS client in a real Windows VM.  This has already surfaced a few bugs (which we fixed), and also ensures that if Microsoft ships an update that changes the behavior we’re relying on, we will automatically get notified.&lt;/p&gt;

&lt;p&gt;An interesting issue that we encountered here was that Windows tends to cache TLS cert verification results, which caused integration tests to interfere with each other.  This caching is generally done on a per-process basis, so spawning a separate PowerShell process for each TLS handshake worked pretty well for avoiding this issue.  (An exception is that Windows has some kind of special caching mechanism for “revoked” status, which is not on a per-process basis.  This meant that our tests for the &lt;code class=&quot;highlighter-rouge&quot;&gt;Disallowed&lt;/code&gt; logical store needed to take extra precautions, specifically sleeping for 30 seconds between consecutive TLS handshakes, so that the cache would expire.  Yes, this is stupid.)&lt;/p&gt;

&lt;p&gt;Another more boring (yet also more amusing) issue we found is that our initial on-a-whim choice of using &lt;code class=&quot;highlighter-rouge&quot;&gt;github.com&lt;/code&gt; as a test case of a TLS cert that was publicly trusted backfired, because &lt;code class=&quot;highlighter-rouge&quot;&gt;github.com&lt;/code&gt; promptly blacklisted our CI VM for rate-limit violations, causing our tests to start failing nondeterministically as soon as we had more than a few test cases.  Oops.  We switched these tests to use &lt;code class=&quot;highlighter-rouge&quot;&gt;namecoin.org&lt;/code&gt;, which seems a tad more ethical, and all is okay now.&lt;/p&gt;

&lt;p&gt;We also did a bunch of code cleanup, based on feedback from static analyzers.&lt;/p&gt;

&lt;h2 id=&quot;so-whats-next&quot;&gt;So what’s next?&lt;/h2&gt;

&lt;p&gt;Stay tuned for a future post on how we’re going to integrate this new &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; functionality into Namecoin.&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
        <link>http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/01/15/external-name-constraints-in-certinject.html</link>
        <guid isPermaLink="true">http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/01/15/external-name-constraints-in-certinject.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Undocumented Windows Feature: External Name Constraints</title>
        <description>&lt;p&gt;Name constraints are a little-known gem of a feature in X.509 certificates, which are used for TLS.  A name constraint is a certificate extension, applied to a CA’s certificate, that contains a whitelist and/or blacklist of names (e.g. domain names) that the CA can issue certs for.  There are 3 main reasons why a CA might want to have a name constraint:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A commercial public CA might sell you a CA for your personal use, with a name constraint that whitelists only domains that you’ve demonstrated that you control.  This works similarly to selling you an end-entity certificate, except that now you can renew your end-entity cert (perhaps rotating keys) without needing to interact with the commercial CA, since you now have your own CA you can use.  This use case isn’t really used in practice, mostly because of regulatory capture (commercial CA’s have successfully made sure that the CA/Browser Forum regulations prohibit issuing name-constrained CA’s to members of the general public).&lt;/li&gt;
  &lt;li&gt;A private CA, perhaps belonging to a corporate intranet or other internal network, wants to limit the damage it can do if it is later compromised, so it includes a name constraint that whitelists a TLD belonging to its intranet.  Thus, if the private CA is later compromised, it can’t be used to attack websites on the public Internet.  This is the stated motivation for Netflix’s BetterTLS test suite.&lt;/li&gt;
  &lt;li&gt;A public CA wants to prevent itself from issuing certificates for specific TLD’s that have unique regulatory requirements that the CA isn’t able to comply with, so it includes a name constraint that blacklists those TLD’s.  Thus, users of those TLD’s don’t have to worry about the public CA affecting their environment.  The best-known example of this is that the Let’s Encrypt CA has sometimes used a name constraint that blacklisted &lt;code class=&quot;highlighter-rouge&quot;&gt;.mil&lt;/code&gt;, presumably because the U.S. military PKI has regulatory requirements that Let’s Encrypt didn’t want to mess with.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All of these use cases are quite valid and legitimate, but they assume one thing: that the CA &lt;em&gt;wanted&lt;/em&gt; to be subjected to a name constraint.  What do you do if you’ve been given a CA certificate that &lt;em&gt;doesn’t&lt;/em&gt; have a name constraint, and you want to only trust it for a subset of names?&lt;/p&gt;

&lt;p&gt;One approach is to cross-sign the CA – in other words, you create your own CA with the name constraint you want, and then produce a cert that’s identical to the CA you want to constrain, except with an issuer and signature from your constrained CA.  This is not too hard; I actually wrote a tool called &lt;code class=&quot;highlighter-rouge&quot;&gt;crosssignnameconstraint&lt;/code&gt; that does this for you.  It works pretty well, but it does produce two potentially unwanted side effects:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It transforms a root CA into an intermediate CA.&lt;/li&gt;
  &lt;li&gt;It changes the fingerprint of the CA.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Both of these can result in unintended behavior from poorly designed TLS implementations, e.g. certificate pinning and EV certificates may behave differently when you cross-sign a certificate.&lt;/p&gt;

&lt;p&gt;So, is there another approach we can use?  If you’re on Windows, then the answer is yes!&lt;/p&gt;

&lt;p&gt;Windows CryptoAPI stores certificates &lt;a href=&quot;/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2017/05/27/reverse-engineering-cryptoapi-cert-blobs.html&quot;&gt;in a kind of funky way&lt;/a&gt;: certificates are stored not just in DER-encoded form, but in a custom data structure called a “certificate blob” that allows “properties” to be attached to the certificates.  One example of such a property is a constraint on which extended key usages a CA can be used for.  For example, you might want to import a CA that’s allowed to issue TLS client certificates but not allowed to issue TLS server certificates or sign code.  When I was looking at the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty#parameters&quot;&gt;list of properties&lt;/a&gt;, most looked pretty mundane, but one jumped out: what the heck is this &lt;code class=&quot;highlighter-rouge&quot;&gt;CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID&lt;/code&gt; thing?  Curiously, the documentation doesn’t say what it does; it’s simply marked as “Reserved”.  However, looking at other properties’ documentation, it became clear that Microsoft has a habit of encoding extensions in ASN.1 format and stuffing the resulting binary data into a property.  I also noticed that the Windows utility &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; actually has a way to edit arbitrary properties of certificates; it’s the (confusingly named) &lt;code class=&quot;highlighter-rouge&quot;&gt;-repairstore&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;So, I cooked up a certificate that had a name constraint blacklisting &lt;code class=&quot;highlighter-rouge&quot;&gt;.github.io&lt;/code&gt;, extracted the ASN.1 binary data for the name constraint extension into a hex blob, and instructed &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; to set it on the built-in root CA that GitHub Pages uses.  I then tried to visit GitHub Pages in Chromium, and &lt;strong&gt;boom&lt;/strong&gt;: a TLS error.  Inspecting the CryptoAPI logs confirmed that the failure was due to a name constraint.&lt;/p&gt;

&lt;p&gt;So, why is this feature there?  Is it being used anywhere?  As far as I can tell, it’s not used by anyone.  The name of the property suggests that Microsoft intended to ship name constraints with its 3rd-party root CA’s, but I briefly checked the entire list of 3rd-party root CA’s, and it appears that none of them have this property set.  The property was added to Windows over a decade ago (if Wine commit dates are to be believed), so perhaps Microsoft used it in the past and then decided to stop.  Or perhaps they planned to use it, abandoned the plan, and left the code in place.  Maybe it was intended for private PKI purposes, but later got shelved.  Microsoft doesn’t document what this property does anywhere, and in fact I was unable to find even a single &lt;em&gt;mention&lt;/em&gt; of this property on the public Internet besides the source code to Microsoft’s header files and the Microsoft documentation that marks it as “Reserved”.  Amusingly, &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; knows exactly what this property is, and if you enable verbose output, it will even happily deserialize the name constraint ASN.1 data into a nice human-readable representation of the name constraint you’re applying.&lt;/p&gt;

&lt;p&gt;Reserved or not, it definitely works, and it seems like a useful addition to a PKI toolbox.  NSS, GnuTLS, and p11-kit do support external name constraints as well, but NSS requires a recompile if you want to change them, and the support in GnuTLS and p11-kit only works on a few distros (and no mainstream browsers).  By supporting external name constraints that are actually enforced in arbitrary applications (including mainstream browsers) and can be edited by the user, Windows is leading the way on an excellent feature (Windows support for this long predates GnuTLS and p11-kit support) – it’s too bad that Microsoft didn’t bother to advertise this as a selling point.&lt;/p&gt;

&lt;p&gt;More details on how we’re going to use this functionality in Namecoin will be in a future post.&lt;/p&gt;
</description>
        <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
        <link>http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/01/14/undocumented-windows-feature-external-name-constraints.html</link>
        <guid isPermaLink="true">http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/01/14/undocumented-windows-feature-external-name-constraints.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin Presentation at Grayhat 2020 Monero Village</title>
        <description>&lt;p&gt;I gave a talk on October 31, 2020, at the &lt;a href=&quot;https://grayhat.co/&quot;&gt;Grayhat 2020&lt;/a&gt; &lt;a href=&quot;https://monerovillage.org/&quot;&gt;Monero Village&lt;/a&gt;, entitled “Namecoin as a Decentralized Alternative to Certificate Authorities for TLS”.  A video recording is below:&lt;/p&gt;

&lt;video controls=&quot;&quot;&gt;
&lt;source src=&quot;http://127.0.0.1:43110/1EZSUprqJQph9JwKg3gAJtiNs899vatZTo/files/videos/grayhat-2020/Grayhat-2020-Namecoin.webm&quot; type=&quot;video/webm&quot; /&gt;
Video of &quot;Namecoin as a Decentralized Alternative to Certificate Authorities for TLS&quot; at Grayhat 2020.
&lt;/video&gt;

&lt;p&gt;Slides are here:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/resources/presentations/Grayhat_2020/Namecoin_TLS_Part_1_Grayhat_2020_Monero_Village.pdf&quot;&gt;Slides (Part 1)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/resources/presentations/Grayhat_2020/Namecoin_TLS_Part_2_Grayhat_2020_Monero_Village.pdf&quot;&gt;Slides (Part 2)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Huge thanks to Diego “rehrar” Salazar from Monero for inviting me!&lt;/p&gt;

&lt;p&gt;License information: Diego’s introduction in the video is under a CC-BY 4.0 license.&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
        <link>http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/01/01/namecoin-at-grayhat-2020-monero-village.html</link>
        <guid isPermaLink="true">http://127.0.0.1:43110/1FPSdChfmaAjMMUgoYLxAYHTDS46gnvmUw/2021/01/01/namecoin-at-grayhat-2020-monero-village.html</guid>
        <dc:creator>Jeremy Rand</dc:creator>
        
        <category>News</category>
        
        
      </item>
    
  </channel>
</rss>
